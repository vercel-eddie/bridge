syntax = "proto3";

package bridge.v1;

message ServerConnection {
  // The URL for sandbox. This needs to be validated to be *.vercel.run.
  string sandbox_url = 1 [json_name = "sandbox_url"];
}

// Message is the unit of communication through the tunnel.
// The first message MUST contain a Registration to identify the connection.
// Subsequent messages contain data to be relayed to the peer.
message Message {
  enum Protocol {
    PROTOCOL_UNSPECIFIED = 0;
    PROTOCOL_TCP = 1;
    PROTOCOL_UDP = 2;
  }

  message Address {
    string ip = 1;
    int32 port = 2;
  }

  message Registration {
    // The Vercel deployment ID that identifies this tunnel.
    string deployment_id = 1 [json_name = "deployment_id"];

    // If true, this is a server (Vercel proxy function).
    // If false, this is a client (local tunnel CLI).
    bool is_server = 2 [json_name = "is_server"];

    // The protocol used for the connection (TCP or UDP).
    Protocol protocol = 3;

    // The URL of the proxy function that bridge should connect to.
    // Only set by clients (is_server=false). Tunneld will open a
    // Connect stream to this URL to establish the server-side connection.
    string function_url = 4 [json_name = "function_url"];

    // The Vercel OIDC token for authentication.
    string oidc_token = 5 [json_name = "oidc_token"];
  }

  // Registration is only sent on the first message to register with bridge.
  optional Registration registration = 1;

  // The address that is sending the message.
  Address source = 2;

  // The intended target address on the destination.
  Address dest = 3;

  // The payload data being tunneled.
  bytes data = 4;

  // Connection ID for multiplexing multiple connections over one tunnel.
  // Each unique source+dest pair represents a logical connection.
  string connection_id = 5 [json_name = "connection_id"];

  // Set to true when the connection should be closed.
  bool close = 6;

  // Error message if something went wrong.
  string error = 7;
}
