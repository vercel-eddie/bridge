// @generated by protoc-gen-es v2.11.0 with parameter "target=js+dts"
// @generated from file bridge/v1/proxy.proto (package bridge.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file bridge/v1/proxy.proto.
 */
export declare const file_bridge_v1_proxy: GenFile;

/**
 * @generated from message bridge.v1.ProxyResolveDNSRequest
 */
export declare type ProxyResolveDNSRequest = Message<"bridge.v1.ProxyResolveDNSRequest"> & {
  /**
   * @generated from field: string hostname = 1;
   */
  hostname: string;
};

/**
 * Describes the message bridge.v1.ProxyResolveDNSRequest.
 * Use `create(ProxyResolveDNSRequestSchema)` to create a new message.
 */
export declare const ProxyResolveDNSRequestSchema: GenMessage<ProxyResolveDNSRequest>;

/**
 * @generated from message bridge.v1.ProxyResolveDNSResponse
 */
export declare type ProxyResolveDNSResponse = Message<"bridge.v1.ProxyResolveDNSResponse"> & {
  /**
   * @generated from field: repeated string addresses = 1;
   */
  addresses: string[];

  /**
   * @generated from field: string error = 2;
   */
  error: string;
};

/**
 * Describes the message bridge.v1.ProxyResolveDNSResponse.
 * Use `create(ProxyResolveDNSResponseSchema)` to create a new message.
 */
export declare const ProxyResolveDNSResponseSchema: GenMessage<ProxyResolveDNSResponse>;

/**
 * @generated from message bridge.v1.TunnelAddress
 */
export declare type TunnelAddress = Message<"bridge.v1.TunnelAddress"> & {
  /**
   * @generated from field: string ip = 1;
   */
  ip: string;

  /**
   * @generated from field: int32 port = 2;
   */
  port: number;
};

/**
 * Describes the message bridge.v1.TunnelAddress.
 * Use `create(TunnelAddressSchema)` to create a new message.
 */
export declare const TunnelAddressSchema: GenMessage<TunnelAddress>;

/**
 * @generated from message bridge.v1.GetMetadataRequest
 */
export declare type GetMetadataRequest = Message<"bridge.v1.GetMetadataRequest"> & {
};

/**
 * Describes the message bridge.v1.GetMetadataRequest.
 * Use `create(GetMetadataRequestSchema)` to create a new message.
 */
export declare const GetMetadataRequestSchema: GenMessage<GetMetadataRequest>;

/**
 * @generated from message bridge.v1.GetMetadataResponse
 */
export declare type GetMetadataResponse = Message<"bridge.v1.GetMetadataResponse"> & {
  /**
   * @generated from field: map<string, string> env_vars = 1;
   */
  envVars: { [key: string]: string };
};

/**
 * Describes the message bridge.v1.GetMetadataResponse.
 * Use `create(GetMetadataResponseSchema)` to create a new message.
 */
export declare const GetMetadataResponseSchema: GenMessage<GetMetadataResponse>;

/**
 * @generated from message bridge.v1.CopyFilesRequest
 */
export declare type CopyFilesRequest = Message<"bridge.v1.CopyFilesRequest"> & {
  /**
   * Absolute paths to read from the pod filesystem.
   *
   * @generated from field: repeated string paths = 1;
   */
  paths: string[];
};

/**
 * Describes the message bridge.v1.CopyFilesRequest.
 * Use `create(CopyFilesRequestSchema)` to create a new message.
 */
export declare const CopyFilesRequestSchema: GenMessage<CopyFilesRequest>;

/**
 * @generated from message bridge.v1.CopyFilesResponse
 */
export declare type CopyFilesResponse = Message<"bridge.v1.CopyFilesResponse"> & {
  /**
   * @generated from field: repeated bridge.v1.FileCopy files = 1;
   */
  files: FileCopy[];
};

/**
 * Describes the message bridge.v1.CopyFilesResponse.
 * Use `create(CopyFilesResponseSchema)` to create a new message.
 */
export declare const CopyFilesResponseSchema: GenMessage<CopyFilesResponse>;

/**
 * @generated from message bridge.v1.FileCopy
 */
export declare type FileCopy = Message<"bridge.v1.FileCopy"> & {
  /**
   * The absolute path of the file or directory.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * The raw file contents (empty for directories).
   *
   * @generated from field: bytes content = 2;
   */
  content: Uint8Array;

  /**
   * File permission mode (e.g. 0644).
   *
   * @generated from field: uint32 mode = 3;
   */
  mode: number;

  /**
   * Modification time as Unix seconds.
   *
   * @generated from field: int64 mod_time = 4;
   */
  modTime: bigint;

  /**
   * Error message if the file could not be read.
   *
   * @generated from field: string error = 5;
   */
  error: string;
};

/**
 * Describes the message bridge.v1.FileCopy.
 * Use `create(FileCopySchema)` to create a new message.
 */
export declare const FileCopySchema: GenMessage<FileCopy>;

/**
 * @generated from message bridge.v1.TunnelNetworkMessage
 */
export declare type TunnelNetworkMessage = Message<"bridge.v1.TunnelNetworkMessage"> & {
  /**
   * The address that is sending the message.
   *
   * @generated from field: bridge.v1.TunnelAddress source = 1;
   */
  source?: TunnelAddress;

  /**
   * The intended target address on the destination.
   *
   * @generated from field: bridge.v1.TunnelAddress dest = 2;
   */
  dest?: TunnelAddress;

  /**
   * Connection ID for multiplexing multiple connections over one stream.
   *
   * @generated from field: string connection_id = 3 [json_name = "connection_id"];
   */
  connectionId: string;

  /**
   * The payload data being tunneled.
   *
   * @generated from field: bytes data = 4;
   */
  data: Uint8Array;

  /**
   * The protocol used for the connection (TCP or UDP).
   *
   * @generated from field: bridge.v1.TunnelProtocol protocol = 5;
   */
  protocol: TunnelProtocol;

  /**
   * Error message if something went wrong.
   *
   * @generated from field: string error = 6;
   */
  error: string;
};

/**
 * Describes the message bridge.v1.TunnelNetworkMessage.
 * Use `create(TunnelNetworkMessageSchema)` to create a new message.
 */
export declare const TunnelNetworkMessageSchema: GenMessage<TunnelNetworkMessage>;

/**
 * @generated from enum bridge.v1.TunnelProtocol
 */
export enum TunnelProtocol {
  /**
   * @generated from enum value: TUNNEL_PROTOCOL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TUNNEL_PROTOCOL_TCP = 1;
   */
  TCP = 1,

  /**
   * @generated from enum value: TUNNEL_PROTOCOL_UDP = 2;
   */
  UDP = 2,
}

/**
 * Describes the enum bridge.v1.TunnelProtocol.
 */
export declare const TunnelProtocolSchema: GenEnum<TunnelProtocol>;

/**
 * BridgeProxyService runs in-cluster and provides DNS resolution and network
 * tunneling to the local bridge intercept client over gRPC.
 *
 * @generated from service bridge.v1.BridgeProxyService
 */
export declare const BridgeProxyService: GenService<{
  /**
   * ResolveDNSQuery resolves a hostname using the in-cluster DNS (CoreDNS).
   * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
   * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
   *
   * @generated from rpc bridge.v1.BridgeProxyService.ResolveDNSQuery
   */
  resolveDNSQuery: {
    methodKind: "unary";
    input: typeof ProxyResolveDNSRequestSchema;
    output: typeof ProxyResolveDNSResponseSchema;
  },
  /**
   * TunnelNetwork tunnels TCP/UDP traffic to an upstream service over a
   * bidirectional stream. Every message carries source/dest addresses and a
   * connection ID so both sides share the same addressing semantics as the
   * WebSocket Message in bridge.proto.
   * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
   * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
   * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
   *
   * @generated from rpc bridge.v1.BridgeProxyService.TunnelNetwork
   */
  tunnelNetwork: {
    methodKind: "bidi_streaming";
    input: typeof TunnelNetworkMessageSchema;
    output: typeof TunnelNetworkMessageSchema;
  },
  /**
   * GetMetadata returns metadata about the bridge proxy, including environment
   * variables from the pod that can be forwarded to the devcontainer.
   *
   * @generated from rpc bridge.v1.BridgeProxyService.GetMetadata
   */
  getMetadata: {
    methodKind: "unary";
    input: typeof GetMetadataRequestSchema;
    output: typeof GetMetadataResponseSchema;
  },
  /**
   * CopyFiles reads files from the bridge proxy pod and returns their contents
   * along with metadata (timestamps, permissions).
   *
   * @generated from rpc bridge.v1.BridgeProxyService.CopyFiles
   */
  copyFiles: {
    methodKind: "unary";
    input: typeof CopyFilesRequestSchema;
    output: typeof CopyFilesResponseSchema;
  },
}>;

